// This file was generated by counterfeiter
package fakes

import (
	"sync"

	"github.com/cloudfoundry/storeadapter"
)

type FakeStoreAdapter struct {
	ConnectStub        func() error
	connectMutex       sync.RWMutex
	connectArgsForCall []struct{}
	connectReturns     struct {
		result1 error
	}
	CreateStub        func(storeadapter.StoreNode) error
	createMutex       sync.RWMutex
	createArgsForCall []struct {
		arg1 storeadapter.StoreNode
	}
	createReturns struct {
		result1 error
	}
	UpdateStub        func(storeadapter.StoreNode) error
	updateMutex       sync.RWMutex
	updateArgsForCall []struct {
		arg1 storeadapter.StoreNode
	}
	updateReturns struct {
		result1 error
	}
	CompareAndSwapStub        func(storeadapter.StoreNode, storeadapter.StoreNode) error
	compareAndSwapMutex       sync.RWMutex
	compareAndSwapArgsForCall []struct {
		arg1 storeadapter.StoreNode
		arg2 storeadapter.StoreNode
	}
	compareAndSwapReturns struct {
		result1 error
	}
	CompareAndSwapByIndexStub        func(prevIndex uint64, newNode storeadapter.StoreNode) error
	compareAndSwapByIndexMutex       sync.RWMutex
	compareAndSwapByIndexArgsForCall []struct {
		prevIndex uint64
		newNode   storeadapter.StoreNode
	}
	compareAndSwapByIndexReturns struct {
		result1 error
	}
	SetMultiStub        func(nodes []storeadapter.StoreNode) error
	setMultiMutex       sync.RWMutex
	setMultiArgsForCall []struct {
		nodes []storeadapter.StoreNode
	}
	setMultiReturns struct {
		result1 error
	}
	GetStub        func(key string) (storeadapter.StoreNode, error)
	getMutex       sync.RWMutex
	getArgsForCall []struct {
		key string
	}
	getReturns struct {
		result1 storeadapter.StoreNode
		result2 error
	}
	ListRecursivelyStub        func(key string) (storeadapter.StoreNode, error)
	listRecursivelyMutex       sync.RWMutex
	listRecursivelyArgsForCall []struct {
		key string
	}
	listRecursivelyReturns struct {
		result1 storeadapter.StoreNode
		result2 error
	}
	DeleteStub        func(keys ...string) error
	deleteMutex       sync.RWMutex
	deleteArgsForCall []struct {
		keys []string
	}
	deleteReturns struct {
		result1 error
	}
	DeleteLeavesStub        func(keys ...string) error
	deleteLeavesMutex       sync.RWMutex
	deleteLeavesArgsForCall []struct {
		keys []string
	}
	deleteLeavesReturns struct {
		result1 error
	}
	CompareAndDeleteStub        func(...storeadapter.StoreNode) error
	compareAndDeleteMutex       sync.RWMutex
	compareAndDeleteArgsForCall []struct {
		arg1 []storeadapter.StoreNode
	}
	compareAndDeleteReturns struct {
		result1 error
	}
	CompareAndDeleteByIndexStub        func(...storeadapter.StoreNode) error
	compareAndDeleteByIndexMutex       sync.RWMutex
	compareAndDeleteByIndexArgsForCall []struct {
		arg1 []storeadapter.StoreNode
	}
	compareAndDeleteByIndexReturns struct {
		result1 error
	}
	UpdateDirTTLStub        func(key string, ttl uint64) error
	updateDirTTLMutex       sync.RWMutex
	updateDirTTLArgsForCall []struct {
		key string
		ttl uint64
	}
	updateDirTTLReturns struct {
		result1 error
	}
	WatchStub        func(key string) (events <-chan storeadapter.WatchEvent, stop chan<- bool, errors <-chan error)
	watchMutex       sync.RWMutex
	watchArgsForCall []struct {
		key string
	}
	watchReturns struct {
		result1 <-chan storeadapter.WatchEvent
		result2 chan<- bool
		result3 <-chan error
	}
	DisconnectStub        func() error
	disconnectMutex       sync.RWMutex
	disconnectArgsForCall []struct{}
	disconnectReturns     struct {
		result1 error
	}
	MaintainNodeStub        func(storeNode storeadapter.StoreNode) (lostNode <-chan bool, releaseNode chan chan bool, err error)
	maintainNodeMutex       sync.RWMutex
	maintainNodeArgsForCall []struct {
		storeNode storeadapter.StoreNode
	}
	maintainNodeReturns struct {
		result1 <-chan bool
		result2 chan chan bool
		result3 error
	}
}

func (fake *FakeStoreAdapter) Connect() error {
	fake.connectMutex.Lock()
	fake.connectArgsForCall = append(fake.connectArgsForCall, struct{}{})
	fake.connectMutex.Unlock()
	if fake.ConnectStub != nil {
		return fake.ConnectStub()
	} else {
		return fake.connectReturns.result1
	}
}

func (fake *FakeStoreAdapter) ConnectCallCount() int {
	fake.connectMutex.RLock()
	defer fake.connectMutex.RUnlock()
	return len(fake.connectArgsForCall)
}

func (fake *FakeStoreAdapter) ConnectReturns(result1 error) {
	fake.ConnectStub = nil
	fake.connectReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeStoreAdapter) Create(arg1 storeadapter.StoreNode) error {
	fake.createMutex.Lock()
	fake.createArgsForCall = append(fake.createArgsForCall, struct {
		arg1 storeadapter.StoreNode
	}{arg1})
	fake.createMutex.Unlock()
	if fake.CreateStub != nil {
		return fake.CreateStub(arg1)
	} else {
		return fake.createReturns.result1
	}
}

func (fake *FakeStoreAdapter) CreateCallCount() int {
	fake.createMutex.RLock()
	defer fake.createMutex.RUnlock()
	return len(fake.createArgsForCall)
}

func (fake *FakeStoreAdapter) CreateArgsForCall(i int) storeadapter.StoreNode {
	fake.createMutex.RLock()
	defer fake.createMutex.RUnlock()
	return fake.createArgsForCall[i].arg1
}

func (fake *FakeStoreAdapter) CreateReturns(result1 error) {
	fake.CreateStub = nil
	fake.createReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeStoreAdapter) Update(arg1 storeadapter.StoreNode) error {
	fake.updateMutex.Lock()
	fake.updateArgsForCall = append(fake.updateArgsForCall, struct {
		arg1 storeadapter.StoreNode
	}{arg1})
	fake.updateMutex.Unlock()
	if fake.UpdateStub != nil {
		return fake.UpdateStub(arg1)
	} else {
		return fake.updateReturns.result1
	}
}

func (fake *FakeStoreAdapter) UpdateCallCount() int {
	fake.updateMutex.RLock()
	defer fake.updateMutex.RUnlock()
	return len(fake.updateArgsForCall)
}

func (fake *FakeStoreAdapter) UpdateArgsForCall(i int) storeadapter.StoreNode {
	fake.updateMutex.RLock()
	defer fake.updateMutex.RUnlock()
	return fake.updateArgsForCall[i].arg1
}

func (fake *FakeStoreAdapter) UpdateReturns(result1 error) {
	fake.UpdateStub = nil
	fake.updateReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeStoreAdapter) CompareAndSwap(arg1 storeadapter.StoreNode, arg2 storeadapter.StoreNode) error {
	fake.compareAndSwapMutex.Lock()
	fake.compareAndSwapArgsForCall = append(fake.compareAndSwapArgsForCall, struct {
		arg1 storeadapter.StoreNode
		arg2 storeadapter.StoreNode
	}{arg1, arg2})
	fake.compareAndSwapMutex.Unlock()
	if fake.CompareAndSwapStub != nil {
		return fake.CompareAndSwapStub(arg1, arg2)
	} else {
		return fake.compareAndSwapReturns.result1
	}
}

func (fake *FakeStoreAdapter) CompareAndSwapCallCount() int {
	fake.compareAndSwapMutex.RLock()
	defer fake.compareAndSwapMutex.RUnlock()
	return len(fake.compareAndSwapArgsForCall)
}

func (fake *FakeStoreAdapter) CompareAndSwapArgsForCall(i int) (storeadapter.StoreNode, storeadapter.StoreNode) {
	fake.compareAndSwapMutex.RLock()
	defer fake.compareAndSwapMutex.RUnlock()
	return fake.compareAndSwapArgsForCall[i].arg1, fake.compareAndSwapArgsForCall[i].arg2
}

func (fake *FakeStoreAdapter) CompareAndSwapReturns(result1 error) {
	fake.CompareAndSwapStub = nil
	fake.compareAndSwapReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeStoreAdapter) CompareAndSwapByIndex(prevIndex uint64, newNode storeadapter.StoreNode) error {
	fake.compareAndSwapByIndexMutex.Lock()
	fake.compareAndSwapByIndexArgsForCall = append(fake.compareAndSwapByIndexArgsForCall, struct {
		prevIndex uint64
		newNode   storeadapter.StoreNode
	}{prevIndex, newNode})
	fake.compareAndSwapByIndexMutex.Unlock()
	if fake.CompareAndSwapByIndexStub != nil {
		return fake.CompareAndSwapByIndexStub(prevIndex, newNode)
	} else {
		return fake.compareAndSwapByIndexReturns.result1
	}
}

func (fake *FakeStoreAdapter) CompareAndSwapByIndexCallCount() int {
	fake.compareAndSwapByIndexMutex.RLock()
	defer fake.compareAndSwapByIndexMutex.RUnlock()
	return len(fake.compareAndSwapByIndexArgsForCall)
}

func (fake *FakeStoreAdapter) CompareAndSwapByIndexArgsForCall(i int) (uint64, storeadapter.StoreNode) {
	fake.compareAndSwapByIndexMutex.RLock()
	defer fake.compareAndSwapByIndexMutex.RUnlock()
	return fake.compareAndSwapByIndexArgsForCall[i].prevIndex, fake.compareAndSwapByIndexArgsForCall[i].newNode
}

func (fake *FakeStoreAdapter) CompareAndSwapByIndexReturns(result1 error) {
	fake.CompareAndSwapByIndexStub = nil
	fake.compareAndSwapByIndexReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeStoreAdapter) SetMulti(nodes []storeadapter.StoreNode) error {
	fake.setMultiMutex.Lock()
	fake.setMultiArgsForCall = append(fake.setMultiArgsForCall, struct {
		nodes []storeadapter.StoreNode
	}{nodes})
	fake.setMultiMutex.Unlock()
	if fake.SetMultiStub != nil {
		return fake.SetMultiStub(nodes)
	} else {
		return fake.setMultiReturns.result1
	}
}

func (fake *FakeStoreAdapter) SetMultiCallCount() int {
	fake.setMultiMutex.RLock()
	defer fake.setMultiMutex.RUnlock()
	return len(fake.setMultiArgsForCall)
}

func (fake *FakeStoreAdapter) SetMultiArgsForCall(i int) []storeadapter.StoreNode {
	fake.setMultiMutex.RLock()
	defer fake.setMultiMutex.RUnlock()
	return fake.setMultiArgsForCall[i].nodes
}

func (fake *FakeStoreAdapter) SetMultiReturns(result1 error) {
	fake.SetMultiStub = nil
	fake.setMultiReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeStoreAdapter) Get(key string) (storeadapter.StoreNode, error) {
	fake.getMutex.Lock()
	fake.getArgsForCall = append(fake.getArgsForCall, struct {
		key string
	}{key})
	fake.getMutex.Unlock()
	if fake.GetStub != nil {
		return fake.GetStub(key)
	} else {
		return fake.getReturns.result1, fake.getReturns.result2
	}
}

func (fake *FakeStoreAdapter) GetCallCount() int {
	fake.getMutex.RLock()
	defer fake.getMutex.RUnlock()
	return len(fake.getArgsForCall)
}

func (fake *FakeStoreAdapter) GetArgsForCall(i int) string {
	fake.getMutex.RLock()
	defer fake.getMutex.RUnlock()
	return fake.getArgsForCall[i].key
}

func (fake *FakeStoreAdapter) GetReturns(result1 storeadapter.StoreNode, result2 error) {
	fake.GetStub = nil
	fake.getReturns = struct {
		result1 storeadapter.StoreNode
		result2 error
	}{result1, result2}
}

func (fake *FakeStoreAdapter) ListRecursively(key string) (storeadapter.StoreNode, error) {
	fake.listRecursivelyMutex.Lock()
	fake.listRecursivelyArgsForCall = append(fake.listRecursivelyArgsForCall, struct {
		key string
	}{key})
	fake.listRecursivelyMutex.Unlock()
	if fake.ListRecursivelyStub != nil {
		return fake.ListRecursivelyStub(key)
	} else {
		return fake.listRecursivelyReturns.result1, fake.listRecursivelyReturns.result2
	}
}

func (fake *FakeStoreAdapter) ListRecursivelyCallCount() int {
	fake.listRecursivelyMutex.RLock()
	defer fake.listRecursivelyMutex.RUnlock()
	return len(fake.listRecursivelyArgsForCall)
}

func (fake *FakeStoreAdapter) ListRecursivelyArgsForCall(i int) string {
	fake.listRecursivelyMutex.RLock()
	defer fake.listRecursivelyMutex.RUnlock()
	return fake.listRecursivelyArgsForCall[i].key
}

func (fake *FakeStoreAdapter) ListRecursivelyReturns(result1 storeadapter.StoreNode, result2 error) {
	fake.ListRecursivelyStub = nil
	fake.listRecursivelyReturns = struct {
		result1 storeadapter.StoreNode
		result2 error
	}{result1, result2}
}

func (fake *FakeStoreAdapter) Delete(keys ...string) error {
	fake.deleteMutex.Lock()
	fake.deleteArgsForCall = append(fake.deleteArgsForCall, struct {
		keys []string
	}{keys})
	fake.deleteMutex.Unlock()
	if fake.DeleteStub != nil {
		return fake.DeleteStub(keys...)
	} else {
		return fake.deleteReturns.result1
	}
}

func (fake *FakeStoreAdapter) DeleteCallCount() int {
	fake.deleteMutex.RLock()
	defer fake.deleteMutex.RUnlock()
	return len(fake.deleteArgsForCall)
}

func (fake *FakeStoreAdapter) DeleteArgsForCall(i int) []string {
	fake.deleteMutex.RLock()
	defer fake.deleteMutex.RUnlock()
	return fake.deleteArgsForCall[i].keys
}

func (fake *FakeStoreAdapter) DeleteReturns(result1 error) {
	fake.DeleteStub = nil
	fake.deleteReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeStoreAdapter) DeleteLeaves(keys ...string) error {
	fake.deleteLeavesMutex.Lock()
	fake.deleteLeavesArgsForCall = append(fake.deleteLeavesArgsForCall, struct {
		keys []string
	}{keys})
	fake.deleteLeavesMutex.Unlock()
	if fake.DeleteLeavesStub != nil {
		return fake.DeleteLeavesStub(keys...)
	} else {
		return fake.deleteLeavesReturns.result1
	}
}

func (fake *FakeStoreAdapter) DeleteLeavesCallCount() int {
	fake.deleteLeavesMutex.RLock()
	defer fake.deleteLeavesMutex.RUnlock()
	return len(fake.deleteLeavesArgsForCall)
}

func (fake *FakeStoreAdapter) DeleteLeavesArgsForCall(i int) []string {
	fake.deleteLeavesMutex.RLock()
	defer fake.deleteLeavesMutex.RUnlock()
	return fake.deleteLeavesArgsForCall[i].keys
}

func (fake *FakeStoreAdapter) DeleteLeavesReturns(result1 error) {
	fake.DeleteLeavesStub = nil
	fake.deleteLeavesReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeStoreAdapter) CompareAndDelete(arg1 ...storeadapter.StoreNode) error {
	fake.compareAndDeleteMutex.Lock()
	fake.compareAndDeleteArgsForCall = append(fake.compareAndDeleteArgsForCall, struct {
		arg1 []storeadapter.StoreNode
	}{arg1})
	fake.compareAndDeleteMutex.Unlock()
	if fake.CompareAndDeleteStub != nil {
		return fake.CompareAndDeleteStub(arg1...)
	} else {
		return fake.compareAndDeleteReturns.result1
	}
}

func (fake *FakeStoreAdapter) CompareAndDeleteCallCount() int {
	fake.compareAndDeleteMutex.RLock()
	defer fake.compareAndDeleteMutex.RUnlock()
	return len(fake.compareAndDeleteArgsForCall)
}

func (fake *FakeStoreAdapter) CompareAndDeleteArgsForCall(i int) []storeadapter.StoreNode {
	fake.compareAndDeleteMutex.RLock()
	defer fake.compareAndDeleteMutex.RUnlock()
	return fake.compareAndDeleteArgsForCall[i].arg1
}

func (fake *FakeStoreAdapter) CompareAndDeleteReturns(result1 error) {
	fake.CompareAndDeleteStub = nil
	fake.compareAndDeleteReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeStoreAdapter) CompareAndDeleteByIndex(arg1 ...storeadapter.StoreNode) error {
	fake.compareAndDeleteByIndexMutex.Lock()
	fake.compareAndDeleteByIndexArgsForCall = append(fake.compareAndDeleteByIndexArgsForCall, struct {
		arg1 []storeadapter.StoreNode
	}{arg1})
	fake.compareAndDeleteByIndexMutex.Unlock()
	if fake.CompareAndDeleteByIndexStub != nil {
		return fake.CompareAndDeleteByIndexStub(arg1...)
	} else {
		return fake.compareAndDeleteByIndexReturns.result1
	}
}

func (fake *FakeStoreAdapter) CompareAndDeleteByIndexCallCount() int {
	fake.compareAndDeleteByIndexMutex.RLock()
	defer fake.compareAndDeleteByIndexMutex.RUnlock()
	return len(fake.compareAndDeleteByIndexArgsForCall)
}

func (fake *FakeStoreAdapter) CompareAndDeleteByIndexArgsForCall(i int) []storeadapter.StoreNode {
	fake.compareAndDeleteByIndexMutex.RLock()
	defer fake.compareAndDeleteByIndexMutex.RUnlock()
	return fake.compareAndDeleteByIndexArgsForCall[i].arg1
}

func (fake *FakeStoreAdapter) CompareAndDeleteByIndexReturns(result1 error) {
	fake.CompareAndDeleteByIndexStub = nil
	fake.compareAndDeleteByIndexReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeStoreAdapter) UpdateDirTTL(key string, ttl uint64) error {
	fake.updateDirTTLMutex.Lock()
	fake.updateDirTTLArgsForCall = append(fake.updateDirTTLArgsForCall, struct {
		key string
		ttl uint64
	}{key, ttl})
	fake.updateDirTTLMutex.Unlock()
	if fake.UpdateDirTTLStub != nil {
		return fake.UpdateDirTTLStub(key, ttl)
	} else {
		return fake.updateDirTTLReturns.result1
	}
}

func (fake *FakeStoreAdapter) UpdateDirTTLCallCount() int {
	fake.updateDirTTLMutex.RLock()
	defer fake.updateDirTTLMutex.RUnlock()
	return len(fake.updateDirTTLArgsForCall)
}

func (fake *FakeStoreAdapter) UpdateDirTTLArgsForCall(i int) (string, uint64) {
	fake.updateDirTTLMutex.RLock()
	defer fake.updateDirTTLMutex.RUnlock()
	return fake.updateDirTTLArgsForCall[i].key, fake.updateDirTTLArgsForCall[i].ttl
}

func (fake *FakeStoreAdapter) UpdateDirTTLReturns(result1 error) {
	fake.UpdateDirTTLStub = nil
	fake.updateDirTTLReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeStoreAdapter) Watch(key string) (events <-chan storeadapter.WatchEvent, stop chan<- bool, errors <-chan error) {
	fake.watchMutex.Lock()
	fake.watchArgsForCall = append(fake.watchArgsForCall, struct {
		key string
	}{key})
	fake.watchMutex.Unlock()
	if fake.WatchStub != nil {
		return fake.WatchStub(key)
	} else {
		return fake.watchReturns.result1, fake.watchReturns.result2, fake.watchReturns.result3
	}
}

func (fake *FakeStoreAdapter) WatchCallCount() int {
	fake.watchMutex.RLock()
	defer fake.watchMutex.RUnlock()
	return len(fake.watchArgsForCall)
}

func (fake *FakeStoreAdapter) WatchArgsForCall(i int) string {
	fake.watchMutex.RLock()
	defer fake.watchMutex.RUnlock()
	return fake.watchArgsForCall[i].key
}

func (fake *FakeStoreAdapter) WatchReturns(result1 <-chan storeadapter.WatchEvent, result2 chan<- bool, result3 <-chan error) {
	fake.WatchStub = nil
	fake.watchReturns = struct {
		result1 <-chan storeadapter.WatchEvent
		result2 chan<- bool
		result3 <-chan error
	}{result1, result2, result3}
}

func (fake *FakeStoreAdapter) Disconnect() error {
	fake.disconnectMutex.Lock()
	fake.disconnectArgsForCall = append(fake.disconnectArgsForCall, struct{}{})
	fake.disconnectMutex.Unlock()
	if fake.DisconnectStub != nil {
		return fake.DisconnectStub()
	} else {
		return fake.disconnectReturns.result1
	}
}

func (fake *FakeStoreAdapter) DisconnectCallCount() int {
	fake.disconnectMutex.RLock()
	defer fake.disconnectMutex.RUnlock()
	return len(fake.disconnectArgsForCall)
}

func (fake *FakeStoreAdapter) DisconnectReturns(result1 error) {
	fake.DisconnectStub = nil
	fake.disconnectReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeStoreAdapter) MaintainNode(storeNode storeadapter.StoreNode) (lostNode <-chan bool, releaseNode chan chan bool, err error) {
	fake.maintainNodeMutex.Lock()
	fake.maintainNodeArgsForCall = append(fake.maintainNodeArgsForCall, struct {
		storeNode storeadapter.StoreNode
	}{storeNode})
	fake.maintainNodeMutex.Unlock()
	if fake.MaintainNodeStub != nil {
		return fake.MaintainNodeStub(storeNode)
	} else {
		return fake.maintainNodeReturns.result1, fake.maintainNodeReturns.result2, fake.maintainNodeReturns.result3
	}
}

func (fake *FakeStoreAdapter) MaintainNodeCallCount() int {
	fake.maintainNodeMutex.RLock()
	defer fake.maintainNodeMutex.RUnlock()
	return len(fake.maintainNodeArgsForCall)
}

func (fake *FakeStoreAdapter) MaintainNodeArgsForCall(i int) storeadapter.StoreNode {
	fake.maintainNodeMutex.RLock()
	defer fake.maintainNodeMutex.RUnlock()
	return fake.maintainNodeArgsForCall[i].storeNode
}

func (fake *FakeStoreAdapter) MaintainNodeReturns(result1 <-chan bool, result2 chan chan bool, result3 error) {
	fake.MaintainNodeStub = nil
	fake.maintainNodeReturns = struct {
		result1 <-chan bool
		result2 chan chan bool
		result3 error
	}{result1, result2, result3}
}

var _ storeadapter.StoreAdapter = new(FakeStoreAdapter)
